package co.datainsider.jobscheduler.repository

import co.datainsider.bi.client.JdbcClient
import co.datainsider.jobscheduler.domain.DataSourceFactory
import co.datainsider.jobscheduler.domain.Ids.SourceId
import co.datainsider.jobscheduler.domain.request.SortRequest
import co.datainsider.jobscheduler.domain.source.{DataSource, DataSourceType}
import co.datainsider.jobscheduler.util.JsonUtils
import com.fasterxml.jackson.databind.JsonNode
import com.google.inject.Inject
import com.twitter.util.Future

import java.sql.ResultSet
import scala.collection.mutable.ArrayBuffer

trait DataSourceRepository {

  def insert(orgId: Long, creatorId: String, source: DataSource): Future[SourceId]

  def update(orgId: Long, source: DataSource): Future[Boolean]

  def delete(orgId: Long, id: SourceId): Future[Boolean]

  def list(orgId: Long, from: Int, size: Int, sorts: Seq[SortRequest], keyword: Option[String]): Future[Seq[DataSource]]

  def count(orgId: Long, keyword: Option[String]): Future[Long]

  def get(orgId: Long, id: SourceId): Future[Option[DataSource]]

  def multiGet(ids: Seq[SourceId]): Future[Map[SourceId, DataSource]]
  def transferOwnerId(orgId: Long, fromUsername: String, toUsername: String): Future[Boolean]

  def listByUsername(orgId: Long, username: String): Future[Seq[DataSource]]

  def deleteByUsername(orgId: Long, username: String): Future[Boolean]

  def multiDelete(orgId: SourceId, ids: Seq[SourceId]) : Future[Boolean]
}

case class MySqlSourceRepository @Inject() (
    dataSourceFactory: DataSourceFactory,
    client: JdbcClient,
    dbName: String,
    tblName: String,
    requiredFields: List[String]
) extends MySqlSchemaManager
    with DataSourceRepository {

  override def list(
      orgId: Long,
      from: Int,
      size: Int,
      sorts: Seq[SortRequest],
      keyword: Option[String]
  ): Future[Seq[DataSource]] =
    Future {
      val orderStatement: String =
        if (sorts.nonEmpty) {
          "order by " + sorts.map(sort => s"${sort.field} ${sort.order}").mkString(",")
        } else {
          ""
        }

      val query =
        s"""
           |select * from $dbName.$tblName
           |where organization_id = ? and name like ?
           |$orderStatement
           |limit ? offset ?;
           |""".stripMargin
      client.executeQuery(query, orgId, s"%${keyword.getOrElse("")}%", size, from)(toDataSources)
    }

  /***
    * @param source data source to be inserted, pass a dummy id, id is auto generated by mysql
    * @return true if source is successfully inserted, false otherwise
    */
  override def insert(orgId: Long, creatorId: String, source: DataSource): Future[SourceId] =
    Future {
      val query =
        s"""
         |insert into $dbName.$tblName
         |(organization_id, name, creator_id, last_modified, data_source_type, data_source_config)
         |values (?, ?, ?, ?, ?, ?);
         |""".stripMargin
      client.executeInsert(
        query,
        orgId,
        source.getName,
        creatorId,
        System.currentTimeMillis(),
        source.getType.toString,
        JsonUtils.toJson(source.getConfig)
      )
    }

  /***
    * data_source_config field of source is in form of json, key value is predefined and need to be get accordingly
    */
  private def toDataSources(rs: ResultSet): Seq[DataSource] = {
    val dataSources = ArrayBuffer.empty[DataSource]
    while (rs.next()) {
      val dataSourceType = DataSourceType.withName(rs.getString("data_source_type"))
      val orgId = rs.getLong("organization_id")
      val id = rs.getLong("id")
      val displayName = rs.getString("name")
      val creatorId: String = rs.getString("creator_id")
      val lastModify: Long = rs.getLong("last_modified")
      val config: JsonNode = JsonUtils.readTree(rs.getString("data_source_config"))
      val ds: DataSource =
        dataSourceFactory.build(dataSourceType, orgId, id, displayName, creatorId, lastModify, config)
      dataSources.append(ds)
    }
    dataSources
  }

  override def delete(orgId: Long, id: SourceId): Future[Boolean] =
    Future {
      val query = s"delete from $dbName.$tblName where organization_id = ? and id = ?;"
      client.executeUpdate(query, orgId, id) > 0
    }

  override def update(orgId: Long, source: DataSource): Future[Boolean] =
    Future {
      val query =
        s"""
         |update $dbName.$tblName
         |set name = ?, data_source_type = ?, data_source_config = ?, last_modified = ?
         |where organization_id = ? and id = ?
         |""".stripMargin

      client.executeUpdate(
        query,
        source.getName,
        source.getType.toString,
        JsonUtils.toJson(source.getConfig, false),
        System.currentTimeMillis(),
        orgId,
        source.getId
      ) > 0
    }

  override def createTable(): Future[Boolean] =
    Future {
      val query =
        s"""
         |create table if not exists $dbName.$tblName (
         |organization_id INT,
         |id BIGINT AUTO_INCREMENT PRIMARY KEY,
         |name TEXT,
         |creator_id TEXT,
         |last_modified BIGINT,
         |data_source_type TINYTEXT,
         |data_source_config LONGTEXT
         |) ENGINE=INNODB;
         |""".stripMargin

      client.executeUpdate(query) >= 0
    }

  override def get(orgId: Long, id: SourceId): Future[Option[DataSource]] =
    Future {
      val query =
        s"""
         |select * from $dbName.$tblName
         |where organization_id = ? and id = ?;
         |""".stripMargin

      client.executeQuery(query, orgId, id)(toDataSources(_).headOption)
    }

  override def multiGet(ids: Seq[Long]): Future[Map[SourceId, DataSource]] =
    Future {
      if (ids.nonEmpty) {
        val query =
          s"""
             |select * from $dbName.$tblName
             |where id in (${Seq.fill(ids.length)("?").mkString(", ")});
             |""".stripMargin

        client.executeQuery(query, ids: _*)(toDataSources).map(dataSource => (dataSource.getId, dataSource)).toMap

      } else Map.empty
    }

  override def count(orgId: Long, keyword: Option[String]): Future[Long] =
    Future {
      val query = s"select count(*) from $dbName.$tblName where organization_id = ? and name like ?;"
      client.executeQuery(query, orgId, s"%${keyword.getOrElse("")}%")(rs => {
        if (rs.next()) rs.getLong(1)
        else 0
      })
    }

  override def transferOwnerId(orgId: SourceId, fromUsername: String, toUsername: String): Future[Boolean] =
    Future {
      val query =
        s"""
         |update $dbName.$tblName
         |set creator_id = ?
         |where organization_id = ? and creator_id = ?
         |""".stripMargin

      client.executeUpdate(query, toUsername, orgId, fromUsername) > 0
    }

  override def listByUsername(orgId: SourceId, username: String): Future[Seq[DataSource]] =
    Future {
      val query =
        s"""
           |select * from $dbName.$tblName
           |where organization_id = ? and creator_id = ?
           |""".stripMargin

      client.executeQuery(query, orgId, username)(toDataSources)
    }

  override def deleteByUsername(orgId: SourceId, username: String): Future[Boolean] =
    Future {
      val query =
        s"""
         |delete from $dbName.$tblName
         |where organization_id = ? and creator_id = ?
         |""".stripMargin

      client.executeUpdate(query, orgId, username) > 0
    }

  override def multiDelete(orgId: SourceId, ids: Seq[SourceId]): Future[Boolean] = Future{
    if (ids.nonEmpty) {
      val query =
        s"""
           |delete from $dbName.$tblName
           |where organization_id = ? and id in (${Seq.fill(ids.length)("?").mkString(", ")})
           |""".stripMargin
        client.executeUpdate(query, orgId +: ids: _*) > 0
    } else {
      true
    }
  }
}
