package co.datainsider.jobscheduler.repository

import co.datainsider.bi.client.JdbcClient
import co.datainsider.jobscheduler.domain.Ids.{JobId, OrgId, SyncId}
import co.datainsider.jobscheduler.domain.JobHistory
import co.datainsider.jobscheduler.domain.job.JobStatus
import co.datainsider.jobscheduler.domain.job.JobStatus.JobStatus
import co.datainsider.jobscheduler.domain.request.SortRequest
import com.google.inject.Inject
import com.twitter.util.Future

import java.sql.ResultSet
import scala.collection.mutable.ArrayBuffer

trait JobHistoryRepository {

  def insert(orgId: Long, jobHistory: JobHistory): Future[SyncId]

  def delete(id: SyncId): Future[Boolean]

  /**
    * only update metadata info: lastSyncTime, totalSyncedTime, syncStatus
    * @param jobHistory new history to replace old history (same id)
    * @return
    */
  def update(jobHistory: JobHistory): Future[Boolean]

  def get(orgId: Long, from: Int, size: Int, sorts: Seq[SortRequest], keyword: Option[String]): Future[Seq[JobHistory]]

  def get(id: SyncId): Future[Option[JobHistory]]

  def getLastHistory(orgId: OrgId, jobId: JobId): Future[Option[JobHistory]]

  def count(orgId: Long, keyword: Option[String]): Future[Long]

  def getWith(withStatus: Seq[JobStatus], from: Int, size: Int): Future[Seq[JobHistory]]

  def getQueuedHistories(jobIds: Seq[JobId]): Future[Map[JobId, JobHistory]]
}

class MySqlJobHistoryRepository @Inject() (
    val client: JdbcClient,
    val dbName: String,
    val tblName: String,
    val requiredFields: List[String]
) extends MySqlSchemaManager
    with JobHistoryRepository {

  override def get(id: SyncId): Future[Option[JobHistory]] =
    Future {
      val query =
        s"""
         |select *
         |from $dbName.$tblName
         |where id = ?;
         |""".stripMargin

      client.executeQuery(query, id)(toHistories).headOption
    }

  override def get(
      orgId: Long,
      from: Int,
      size: Int,
      sorts: Seq[SortRequest],
      keyword: Option[String]
  ): Future[Seq[JobHistory]] =
    Future {
      val orderStatement: String =
        if (sorts.nonEmpty) {
          "order by " + sorts.map(sort => s"${sort.field} ${sort.order}").mkString(",")
        } else {
          ""
        }

      val query =
        s"""
           |select * from $dbName.$tblName
           |where organization_id = ? and job_name like ?
           |$orderStatement
           |limit ? offset ?;
           |""".stripMargin
      client.executeQuery(query, orgId, s"%${keyword.getOrElse("")}%", size, from)(toHistories)
    }

  override def update(history: JobHistory): Future[Boolean] =
    Future {
      val query =
        s"""
         |update $dbName.$tblName
         |set last_sync_time = ?, total_sync_time = ?, sync_status = ?, total_inserted_rows = ?, message = ?
         |where id = ?;
         |""".stripMargin

      client.executeUpdate(
        query,
        history.lastSyncTime,
        history.totalSyncedTime,
        history.syncStatus.toString,
        history.totalRowsInserted,
        history.message,
        history.syncId
      ) > 0
    }

  override def getWith(withStatuses: Seq[JobStatus], from: Int, size: Int): Future[Seq[JobHistory]] =
    Future {
      val questionMarkHolder = List.fill(withStatuses.length)("?").mkString(",")
      val query =
        s"""
         |select * from $dbName.$tblName
         |where sync_status in ($questionMarkHolder)
         |limit $size offset $from;
         |""".stripMargin

      client.executeQuery(query, withStatuses.map(_.toString): _*)(toHistories)
    }

  override def getQueuedHistories(jobIds: Seq[JobId]): Future[Map[JobId, JobHistory]] =
    Future {
      if (jobIds.nonEmpty) {
        val query =
          s"""
             |select * from $dbName.$tblName
             |where sync_status = 'Queued'
             |  and job_id in (${Seq.fill(jobIds.length)("?").mkString(", ")});
             |""".stripMargin

        client.executeQuery(query, jobIds: _*)(toHistories).map(history => (history.jobId -> history)).toMap

      } else Map.empty
    }

  /**
    * @param jobHistory history to be inserted, pass a dummy id, id is auto generated by mysql
    * @return
    */
  override def insert(orgId: Long, jobHistory: JobHistory): Future[SyncId] =
    Future {
      val query =
        s"""
         |insert into $dbName.$tblName
         |(organization_id, job_id, job_name, last_sync_time, total_sync_time, sync_status, total_inserted_rows, message)
         |values (?, ?, ?, ?, ?, ?, ?, ?)
         |""".stripMargin

      client.executeInsert(
        query,
        orgId,
        jobHistory.jobId,
        jobHistory.jobName,
        jobHistory.lastSyncTime,
        jobHistory.totalSyncedTime,
        jobHistory.syncStatus.toString,
        jobHistory.totalRowsInserted,
        jobHistory.message
      )
    }

  override def delete(id: SyncId): Future[Boolean] =
    Future {
      val query = s"delete from $dbName.$tblName where id = ?;"
      client.executeUpdate(query, id) > 0
    }

  private def toHistories(rs: ResultSet): Seq[JobHistory] = {
    val histories = ArrayBuffer.empty[JobHistory]
    while (rs.next()) {
      val history = JobHistory(
        syncId = rs.getLong("id"),
        jobId = rs.getLong("job_id"),
        jobName = rs.getString("job_name"),
        lastSyncTime = rs.getLong("last_sync_time"),
        totalSyncedTime = rs.getLong("total_sync_time"),
        syncStatus = JobStatus.withName(rs.getString("sync_status")),
        totalRowsInserted = rs.getLong("total_inserted_rows"),
        message = rs.getString("message")
      )
      histories += history
    }
    histories
  }

  override def createTable(): Future[Boolean] =
    Future {
      val query =
        s"""
         |create table if not exists $dbName.$tblName (
         |organization_id INT,
         |id BIGINT AUTO_INCREMENT PRIMARY KEY,
         |job_id BIGINT,
         |job_name TEXT,
         |last_sync_time BIGINT,
         |total_sync_time BIGINT,
         |sync_status TINYTEXT,
         |total_inserted_rows BIGINT,
         |message TEXT
         |) ENGINE=INNODB;
         |""".stripMargin

      client.executeUpdate(query) >= 0
    }

  override def count(orgId: Long, keyword: Option[String]): Future[Long] =
    Future {
      val query = s"select count(*) from $dbName.$tblName where organization_id = ? and job_name like ?;"
      client.executeQuery(query, orgId, s"%${keyword.getOrElse("")}%")(rs => {
        if (rs.next()) rs.getLong(1)
        else 0L
      })
    }

  private def toOrderBy(sort: SortRequest): String = {
    s"? ${sort.order}"
  }

  override def getLastHistory(orgId: OrgId, jobId: JobId): Future[Option[JobHistory]] =
    Future {
      val query =
        s"""
         |select * from $dbName.$tblName
         |where organization_id = ? and job_id = ?
         |order by id desc
         |limit 1
         |""".stripMargin

      client.executeQuery(query, orgId, jobId)(toHistories).headOption
    }
}
