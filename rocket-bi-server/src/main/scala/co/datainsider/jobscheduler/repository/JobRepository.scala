package co.datainsider.jobscheduler.repository

import co.datainsider.bi.client.JdbcClient
import co.datainsider.bi.client.JdbcClient.Record
import co.datainsider.bi.util.ZConfig
import co.datainsider.jobscheduler.domain.Ids.{JobId, SourceId}
import co.datainsider.jobscheduler.domain.job.JobStatus.JobStatus
import co.datainsider.jobscheduler.domain.job.JobType.JobType
import co.datainsider.jobscheduler.domain.job._
import co.datainsider.jobscheduler.domain.request.SortRequest
import co.datainsider.jobscheduler.util.JsonUtils
import com.google.inject.Inject
import com.twitter.util.Future

import java.sql.ResultSet
import scala.collection.mutable.ArrayBuffer

trait JobRepository {

  def insert(orgId: Long, creatorId: String, job: Job): Future[JobId]

  def count(orgId: Long, keyword: Option[String], currentStatuses: Seq[JobStatus]): Future[Long]

  def delete(orgId: Long, jobId: Option[JobId], sourceId: Option[SourceId]): Future[Boolean]

  def update(orgId: Long, job: Job): Future[Boolean]

  def get(orgId: Long, jobId: JobId): Future[Option[Job]]

  def list(
      orgId: Long,
      from: Int,
      size: Int,
      sorts: Seq[SortRequest],
      keyword: Option[String],
      currentStatuses: Seq[JobStatus]
  ): Future[Seq[Job]]

  def getWith(orgId: Long, jobStatus: List[JobStatus], from: Int, size: Int): Future[Seq[Job]]

  /** *
    * get next job to be process by JobWorker
    * ** there are two type of job: full sync and incremental sync, if <sync_interval> <= 0 full sync else incremental sync
    * ** full sync only schedule 1 time
    * ** incremental sync scheduler every <sync_interval>
    * @return first job with time ascending order with [(last_successful_sync + sync_interval_in_mn) <= current_timestamp]
    *         and [current_sync_status != Queued && current_sync_status != Syncing]
    */
  def getNextJob(): Future[Option[Job]]

  def multiInsert(orgId: Long, creatorId: String, jobs: Seq[Job]): Future[Boolean]

  def getQueuedJobs(): Future[Seq[Job]]

  def deleteBySourceIds(orgId: Long, sourceId: Seq[SourceId]): Future[Boolean]

  def multiDelete(orgId: Long, jobIds: Seq[JobId]): Future[Boolean]

  def fixJosStatuses(): Future[Boolean]

}

class MySqlJobRepository @Inject() (
    val client: JdbcClient,
    val dbName: String,
    val tblName: String,
    val requiredFields: List[String]
) extends MySqlSchemaManager
    with JobRepository {

  override def get(orgId: Long, jobId: JobId): Future[Option[Job]] = {
    Future {
      val query = s"select * from $dbName.$tblName where organization_id = ? and id = ?;"
      client.executeQuery(query, orgId, jobId)(toJobs).headOption
    }
  }

  override def list(
      orgId: Long,
      from: Int,
      size: Int,
      sorts: Seq[SortRequest],
      keyword: Option[String],
      currentStatuses: Seq[JobStatus]
  ): Future[Seq[Job]] =
    Future {
      val orderStatement: String = if (sorts.nonEmpty) {
        "order by " + sorts.map(sort => s"${sort.field} ${sort.order}").mkString(",")
      } else {
        ""
      }
      val whereStatement: String = if (currentStatuses.nonEmpty) {
        val questionMarkHolder: String = List.fill(currentStatuses.size)("?").mkString(",")
        s"where organization_id = ? and name like ? and current_sync_status in ($questionMarkHolder)"
      } else {
        "where organization_id = ? and name like ?"
      }
      val query =
        s"""SELECT *
           |FROM $dbName.$tblName
           |$whereStatement
           |$orderStatement
           |LIMIT ? OFFSET ?;
           |""".stripMargin
      val params = Array(orgId, s"%${keyword.getOrElse("")}%") ++ currentStatuses.map(_.toString) ++ Array(size, from)
      client.executeQuery(query, params: _*)(toJobs)
    }

  override def getWith(
      orgId: Long,
      jobStatuses: List[JobStatus],
      from: Int,
      size: Int
  ): Future[Seq[Job]] =
    Future {
      if (jobStatuses.isEmpty) return Future(List.empty)
      val questionMarkHolder: String = List.fill(jobStatuses.size)("?").mkString(",")
      val query =
        s"""
           |select * from $dbName.$tblName
           |where current_sync_status in ($questionMarkHolder) and organization_id = $orgId
           |limit $size offset $from;
           |""".stripMargin
      client.executeQuery(query, jobStatuses.map(_.toString): _*)(
        toJobs
      )
    }

  /**
    * @param job job to be inserted, id field is dummy and can be passed with any number, id field is auto generated by mysql
    * @return
    */
  override def insert(orgId: Long, creatorId: String, job: Job): Future[JobId] =
    Future {
      val query =
        s"""
         |insert into $dbName.$tblName
         |(organization_id, name, job_type, creator_id, last_modified, sync_mode, source_id, last_successful_sync, sync_interval_in_mn, next_run_time, last_sync_status, current_sync_status, destination_db, destination_tbl, job_data)
         |values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
         |""".stripMargin

      client.executeInsert(
        query,
        orgId,
        job.displayName,
        job.jobType.toString,
        creatorId,
        System.currentTimeMillis(),
        job.syncMode.toString,
        job.sourceId,
        job.lastSuccessfulSync,
        job.syncIntervalInMn,
        job.nextRunTime,
        job.lastSyncStatus.toString,
        job.currentSyncStatus.toString,
        job.destDatabaseName,
        job.destTableName,
        JsonUtils.toJson(job.jobData)
      )
    }

  override def delete(orgId: Long, jobId: Option[JobId], sourceId: Option[SourceId]): Future[Boolean] =
    Future {
      var whereClause = ""
      if (jobId.isDefined) whereClause += s" and id = ${jobId.get} and organization_id = $orgId"
      if (sourceId.isDefined) whereClause += s" and source_id = ${sourceId.get} and organization_id = $orgId"
      val query = s"delete from $dbName.$tblName where 1=1 $whereClause"
      client.executeUpdate(query) >= 0
    }

  /** *
    * job_data field of source is in form of json, key value is predefined and need to be get accordingly
    */
  private def toJobs(rs: ResultSet): Seq[Job] = {
    val jobs = ArrayBuffer.empty[Job]
    while (rs.next()) {
      val jobType: JobType = JobType.withName(rs.getString("job_type"))
      val job: Job = jobType match {
        case JobType.Jdbc                => JdbcJob.fromResultSet(rs)
        case JobType.GenericJdbc         => GenericJdbcJob.fromResultSet(rs)
        case JobType.Ga                  => GaJob.fromResultSet(rs)
        case JobType.Hubspot             => HubspotJob.fromResultSet(rs)
        case JobType.FacebookAds         => FacebookAdsJob.fromResultSet(rs)
        case JobType.GoogleSheets        => GoogleSheetJob.fromResultSet(rs)
        case JobType.GoogleSheetsV2      => GoogleSheetJobV2.fromResultSet(rs)
        case JobType.MongoDb             => MongoJob.fromResultSet(rs)
        case JobType.Solana              => SolanaJob.fromResultSet(rs)
        case JobType.Bigquery            => BigQueryStorageJob.fromResultSet(rs)
        case JobType.CoinMarketCap       => CoinMarketCapJob.fromResultSet(rs)
        case JobType.Shopify             => ShopifyJob.fromResultSet(rs)
        case JobType.S3                  => AmazonS3Job.fromResultSet(rs)
        case JobType.GoogleAds           => GoogleAdsJob.fromResultSet(rs)
        case JobType.Ga4                 => Ga4Job.fromResultSet(rs)
        case JobType.TikTokAds           => TikTokAdsJob.fromResultSet(rs)
        case JobType.Shopee              => ShopeeJob.fromResultSet(rs)
        case JobType.Lazada              => LazadaJob.fromResultSet(rs)
        case JobType.Palexy              => PalexyJob.fromResultSet(rs)
        case JobType.GoogleSearchConsole => GoogleSearchConsoleJob.fromResultSet(rs)
        case _                           => throw new UnsupportedOperationException
      }
      jobs += job
    }
    jobs
  }

  override def createTable(): Future[Boolean] =
    Future {
      val query =
        s"""
         |create table if not exists $dbName.$tblName (
         |organization_id INT,
         |id BIGINT AUTO_INCREMENT PRIMARY KEY,
         |name TEXT,
         |job_type TINYTEXT,
         |creator_id TEXT,
         |last_modified BIGINT,
         |sync_mode TINYTEXT,
         |source_id BIGINT,
         |last_successful_sync BIGINT,
         |sync_interval_in_mn INT,
         |next_run_time BIGINT DEFAULT 0,
         |last_sync_status TINYTEXT,
         |current_sync_status TINYTEXT,
         |destination_db TINYTEXT,
         |destination_tbl TINYTEXT,
         |job_data TEXT
         |) ENGINE=INNODB;
         |""".stripMargin

      client.executeUpdate(query) >= 0
    }

  override def getNextJob(): Future[Option[Job]] =
    Future {
      val biServiceDbName = if (isTestEnv) {
        ZConfig.getString("database_schema_testing.database.name")
      } else ZConfig.getString("database_schema.database.name")

      val query =
        s"""
         |select *
         |from $biServiceDbName.connection
         |  left join $dbName.$tblName on org_id = organization_id
         |where unix_timestamp() * 1000 >= next_run_time
         |and current_sync_status != 'Queued'
         |and current_sync_status != 'Syncing'
         |order by next_run_time ASC;
         |""".stripMargin

      client.executeQuery(query)(rs => {
        val jobs = toJobs(rs)
        jobs.headOption
      })
    }

  override def update(orgId: Long, job: Job): Future[Boolean] =
    Future {
      val query =
        s"""
         |update $dbName.$tblName
         |set name = ?, job_type = ?, last_modified = ?, sync_mode = ?, source_id = ?,
         |last_successful_sync = ?, sync_interval_in_mn = ?, next_run_time = ?,
         |last_sync_status = ?, current_sync_status = ?,
         |destination_db = ?, destination_tbl = ?, job_data = ?
         |where organization_id = ? and id = ?;
         |""".stripMargin

      client.executeUpdate(
        query,
        job.displayName,
        job.jobType.toString,
        System.currentTimeMillis(),
        job.syncMode.toString,
        job.sourceId,
        job.lastSuccessfulSync,
        job.syncIntervalInMn,
        job.nextRunTime,
        job.lastSyncStatus.toString,
        job.currentSyncStatus.toString,
        job.destDatabaseName,
        job.destTableName,
        JsonUtils.toJson(job.jobData),
        orgId,
        job.jobId
      ) >= 0
    }

  override def count(orgId: Long, keyword: Option[String], statuses: Seq[JobStatus]): Future[Long] =
    Future {
      val whereStatement: String = if (statuses.nonEmpty) {
        val questionMarkHolder: String = List.fill(statuses.size)("?").mkString(",")
        s"where organization_id = ? and name like ? and current_sync_status in ($questionMarkHolder)"
      } else {
        "where organization_id = ? and name like ?"
      }
      val query: String = s"SELECT count(1) FROM $dbName.$tblName ${whereStatement}"
      val params = Array(orgId, s"%${keyword.getOrElse("")}%") ++ statuses.map(_.toString)
      client.executeQuery(query, params: _*)(rs => {
        if (rs.next()) rs.getLong(1)
        else 0
      })
    }

  override def multiInsert(orgId: JobId, creatorId: String, jobs: Seq[Job]): Future[Boolean] =
    Future {
      val query =
        s"""
         |insert into $dbName.$tblName
         |(organization_id, name, job_type, creator_id, last_modified, sync_mode, source_id, last_successful_sync, sync_interval_in_mn, next_run_time, last_sync_status, current_sync_status, destination_db, destination_tbl, job_data)
         |values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);
         |""".stripMargin
      client.executeBatchUpdate(query, toMultiInsertInput(orgId, creatorId, jobs)) > 0
    }

  override def getQueuedJobs(): Future[Seq[Job]] =
    Future {
      val query =
        s"""
         |select * from $dbName.$tblName
         |where current_sync_status = 'Queued'
         |order by next_run_time ASC;
         |""".stripMargin

      client.executeQuery(query)(toJobs)
    }

  private def toMultiInsertInput(orgId: JobId, creatorId: String, jobs: Seq[Job]): Array[Record] = {
    jobs
      .map(job => {
        Array(
          orgId,
          job.displayName,
          job.jobType.toString,
          creatorId,
          System.currentTimeMillis(),
          job.syncMode.toString,
          job.sourceId,
          job.lastSuccessfulSync,
          job.syncIntervalInMn,
          job.nextRunTime,
          job.lastSyncStatus.toString,
          job.currentSyncStatus.toString,
          job.destDatabaseName,
          job.destTableName,
          JsonUtils.toJson(job.jobData)
        )
      })
      .toArray
  }

  override def deleteBySourceIds(orgId: JobId, sourceIds: Seq[SourceId]): Future[Boolean] =
    Future {
      if (sourceIds.isEmpty) {
        true
      } else {
        val query =
          s"""
          |delete from ${dbName}.${tblName}
          |where organization_id = ? and source_id in (${Array.fill(sourceIds.size)("?").mkString(",")});
          |""".stripMargin
        val args = Seq(orgId) ++ sourceIds
        client.executeUpdate(query, args: _*) >= 0
      }
    }

  override def multiDelete(orgId: JobId, jobIds: Seq[JobId]): Future[Boolean] = {
    Future {
      if (jobIds.isEmpty) {
        true
      } else {
        val query =
          s"""
          |DELETE FROM ${dbName}.${tblName}
          |WHERE organization_id = ? and id in (${Array.fill(jobIds.size)("?").mkString(",")});
          |""".stripMargin
        val args = Seq(orgId) ++ jobIds
        client.executeUpdate(query, args: _*) >= 0
      }
    }
  }

  override def fixJosStatuses(): Future[Boolean] = {
    Future {
      val query =
        s"""
           |update $dbName.$tblName
           |set current_sync_status = ?
           |where current_sync_status = ? || current_sync_status = ?
           |""".stripMargin

      client.executeUpdate(
        query,
        JobStatus.Terminated.toString,
        JobStatus.Syncing.toString,
        JobStatus.Queued.toString
      ) >= 0
    }
  }

  private def isTestEnv: Boolean = {
    val env = System.getProperty("mode", "local")
    env != "production" && env != "development"
  }
}
